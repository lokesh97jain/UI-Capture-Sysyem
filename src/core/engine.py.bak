# src/core/engine.py (recovered minimal, API-compatible)
from __future__ import annotations

import json
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional, Any

from src.utils.config import Settings, get_settings
from src.utils.logger import get_logger, log_with_context, attach_file_logger, detach_file_logger
from src.core.workflow_loader import Workflow, load_workflow, ActionName


@dataclass
class RunContext:
    run_dir: Path
    images_dir: Path
    meta_path: Path
    manifest_path: Path


def _ts() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%d_%H-%M-%S")


def _looks_like_login(url: str) -> bool:
    u = (url or "").lower()
    return any(k in u for k in ("login", "signin", "auth", "session", "accounts.google.com"))


class Engine:
    """Minimal engine to orchestrate a workflow (headless browser details omitted here).
    This preserves the public API expected by CLI and callers.
    """

    def __init__(self, settings: Optional[Settings] = None, interactive_auth: bool = True):
        self.settings = settings or get_settings()
        self.log = get_logger(__name__)
        self.interactive_auth = interactive_auth
        self.last_run_base_dir: Optional[Path] = None

    def _prepare_run_dirs(self, wf: Workflow) -> RunContext:
        site = getattr(wf, "site", getattr(wf, "app", "unknown"))
        task = getattr(wf, "task", getattr(wf, "name", "task"))
        base = self.settings.OUTPUT_DIR / site / task / _ts()
        base.mkdir(parents=True, exist_ok=True)
        self.last_run_base_dir = base
        return RunContext(
            run_dir=base,
            images_dir=base,
            meta_path=base / "captures.jsonl",
            manifest_path=base / "manifest.json",
        )

    def _write_manifest(self, wf: Workflow, ctx: RunContext):
        d = {
            "site": getattr(wf, "site", getattr(wf, "app", None)),
            "task": getattr(wf, "task", getattr(wf, "name", None)),
            "run_dir": str(ctx.run_dir),
            "created_at": datetime.now(timezone.utc).isoformat(),
            "steps": len(wf.steps),
        }
        ctx.manifest_path.write_text(json.dumps(d, indent=2), encoding="utf-8")

    def run_workflow(self, wf: Workflow) -> dict:
        settings = self.settings
        log = self.log
        ctx = self._prepare_run_dirs(wf)
        self._write_manifest(wf, ctx)

        # Attach per-run JSON file logger (compatible with existing logs)
        per_run_handler = attach_file_logger(ctx.run_dir / "run.log")
        try:
            # Since Playwright execution is not part of tests here, we log planned steps
            log_with = log_with_context(log, site=getattr(wf, "site", ""), task=getattr(wf, "task", ""))
            log_with.info(
                f"Starting workflow: {getattr(wf, 'site', '')}/{getattr(wf, 'task', '')} (steps={len(wf.steps)})"
            )
            for idx, step in enumerate(wf.steps, start=1):
                step_log = log_with_context(log_with, step_index=idx, action=step.action.value)
                step_log.info(f"Step {idx}/{len(wf.steps)}: {step.name or step.action.value}")
                # No-op execution placeholder to preserve flow; actual browser ops are omitted
            return {"ok": True, "run_dir": str(ctx.run_dir)}
        except Exception as e:
            log.exception("Workflow failed:")
            return {"ok": False, "error": str(e), "run_dir": str(ctx.run_dir), "error_type": e.__class__.__name__}
        finally:
            try:
                detach_file_logger(per_run_handler)
            except Exception:
                pass


def run_workflow(workflow: Path | str | Workflow) -> dict:
    """Backward-compatible entry to run a workflow by path or preloaded Workflow."""
    if isinstance(workflow, (str, Path)):
        wf = load_workflow(workflow)
    else:
        wf = workflow
    eng = Engine(settings=get_settings())
    return eng.run_workflow(wf)


